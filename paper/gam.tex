\section{General Atomic Memory Model (GAM)}\label{sec:GAM}

In this section, we introduce GAM, an atomic memory model framework parametrized by how the memory model enforces following two types of orderings:
\begin{enumerate}
    \item Memory instruction ordering: the ordering between two memory instructions, i.e., the commonly referred load-load, load-store, store-store and store-load orderings.
    \item Fence ordering, the ordering between a fence and a memory instruction or between two fences.
\end{enumerate}
We refer to the combination of the above two orderings as \emph{memory/fence ordering}.
GAM uses a function $\OrderedFunc(I_{old}, I_{new})$ to represent memory/fence ordering, and this function is used in both the axiomatic and operational definitions of GAM.
$\OrderedFunc(I_{old}, I_{new})$ returns true when the older instruction $I_{old}$ should be ordered before the younger instruction $I_{new}$ according to the memory instruction ordering or fence ordering enforced by the memory model.
For example, Table~\ref{tab:order-tso} shows the $\OrderedFunc(I_{old}, I_{new})$ table for TSO, which has only one type of fence.
The only memory ordering that is not enforced by TSO is the store-load ordering, as represented by the false entry (St, Ld).
As a more complex example, Table~\ref{tab:order-rmo} shows the $\OrderedFunc(I_{old}, I_{new})$ table for RMO.
In RMO, all four memory instruction orderings are relaxed, as shown by the false entries (Ld, Ld), (Ld, St), (St, Ld) and (St, St).
The four fences are used to enforce each type of orderings respectively.
For example, the true entries (FenceLS, St) and (Ld, FenceLS) means that FenceLS is ordered before younger stores and is ordered after older loads, thus enforce load-to-store ordering.
The fences are even unordered with respect to each other.
As a framework, given an $\OrderedFunc$ function (such as Table~\ref{tab:order-tso} or \ref{tab:order-rmo}), GAM can produce equivalent axiomatic and operational models that enforce the memory/fence orderings represented by the $\OrderedFunc$ function.

\begin{table}[!htb]
    \centering
    \begin{tabular}{|l|l|l|l|}
        \hline
        \backslashbox{$I_{old}$}{$I_{new}$} & Ld    & St    & Fence \\ \hline
        Ld                                  & True  & True  & True  \\ \hline
        St                                  & False & True  & True  \\ \hline
        Fence                               & True  & True  & True  \\ \hline
    \end{tabular}
    \caption{Orderings for TSO memory instructions and fences: $\OrderedFunc_{TSO}(I_{old}, I_{new})$}\label{tab:order-tso}
\end{table}
\begin{table}[!htb]
    \centering
    \begin{tabular}{|l|l|l|l|l|l|l|}
        \hline
        \backslashbox{$I_{old}$}{$I_{new}$} & Ld    & St    & FenceLL   & FenceLS   & FenceSL   & FenceSS \\ \hline
        Ld                                  & False & False & True      & True      & False     & False \\ \hline
        St                                  & False & False & False     & False     & True      & True  \\ \hline
        FenceLL                             & True  & False & False     & False     & False     & False \\ \hline
        FenceLS                             & False & True  & False     & False     & False     & False \\ \hline
        FenceSL                             & True  & False & False     & False     & False     & False \\ \hline
        FenceSS                             & False & True  & False     & False     & False     & False \\ \hline
    \end{tabular}
    \caption{Orderings for RMO memory instructions and fences: $\OrderedFunc_{RMO}(I_{old}, I_{new})$}\label{tab:order-rmo}
\end{table}

It should be noted that the memory/fence ordering cannot fully describe a memory model.
The following three aspects are not captured by the $\OrderedFunc$ function:
\begin{enumerate}
    \item Load value: a memory model must specify which store values a load may read.
    \item Dependency ordering: most memory models order two instructions if the younger instruction is dependent on the older instruction in certain ways.
    \item Same-address ordering: even when the memory/fence ordering does not apply to two memory instructions for the same address, a memory model may still order them for the correctness of single-threaded programs.
\end{enumerate}
The GAM definition given in this section is not parametrized in terms of the above three aspects.
Later in Section~\ref{sec:instance}, we will show how to tweak the definition of GAM to derive memory models with a different dependency ordering or a different same-address ordering.
The way to determine load values should be common across all multicopy atomic memory models, so we do not bother changing that.
In the following, we give axiomatic and operation definitions of GAM and the equivalence proof.
When we use examples to explain our definitions, we assume the $\OrderedFunc$ function in Table~\ref{tab:order-rmo}, i.e., with all four memory instruction reorderings and relaxed fences.

We present the axiomatic definition before the operational definition but these definitions can be read in any order.

\subsection{Axiomatic Definition of GAM}
\label{sec:gam:axiom}

The axiomatic definition of GAM takes three relations as input: program order ($\ProgOrd$), read-from relations ($\ReadFrom$) and memory order ($\MemOrd$).
The program order ($\ProgOrd$) is a per-processor total order and represents the order in which the instructions are committed in that processor.
A read-from edge specifies that a load reads from a particular store; $\ReadFrom$ points from a store instruction to a load instruction for the same address, with the load getting the same value that is written by the store.
The memory order ($\MemOrd$) is a total order of all memory instructions in all processors.
Intuitively, $\MemOrd$ specifies the order of when each memory accesses are performed globally.

The axiomatic model checks $\ProgOrd$, $\ReadFrom$ and $\MemOrd$ against a set of axioms.
If all the axioms are satisfied, then the program behavior given by $\ProgOrd$ is allowed by the memory model.

It should be noted that $\ProgOrd$ is the observable program behavior, while $\ReadFrom$ and $\ProgOrd$ are just a \emph{witness} which cannot be observed directly.
To justify that a program behavior is allowed by GAM, we only need to find one witness (i.e., $\langle \ReadFrom, \MemOrd\rangle$) that satisfies all the axioms.
To prove that a program behavior is disallowed by GAM, we must show that there is no witness that can satisfy all the axioms simultaneously.

In order to describe the axioms, we first define \emph{preserved program order} ($\PreservePO$), which is computed from $\ProgOrd$.
$\PreservePO$ captures the constraints on the out-of-order (OOO) execution of instructions in each processor (locally).
Thus, a property of $\PreservePO$ is that if $I_1 \PreservePO I_2$ then $I_1 \ProgOrd I_2$ where $I_1$ and $I_2$ are instructions.

As will become clear $\ProgOrd$ by itself cannot reflect the constraints on the memory system and the interaction between processors.  
These constraints are expressed by the separate memory axioms of GAM.
In the following, we first define how to compute $\PreservePO$ from $\ProgOrd$, and then give the memory axioms of GAM.

\subsubsection{Definition of Preserved Program Order $<_{ppo}$ for GAM}\label{sec:ppo}

We define $\PreservePO$ in three parts.
The first part is the \emph{preserved memory/fence order} ($\LSFOrd$) which is captured by the $\OrderedFunc$ function.
The second part is the \emph{preserved dependency order} ($\DepOrd$), which includes branch dependencies, address dependencies, data dependencies, etc.
The last part is the \emph{preserved same-address order} ($\SameAddrOrd$), i.e., the ordering of memory instructions for the same address. 
Finally $\PreservePO$ is defined as the transitive closure of $\LSFOrd$, $\DepOrd$ and $\SameAddrOrd$.

\noindent\textbf{Definition of preserved memory/fence order $\LSFOrd$ for GAM:}
The preserved memory/fence order is fully described by the $\OrderedFunc$ function.
\begin{definition}[Preserved memory/fence order $\LSFOrd$\label{def:ppo-mem-fence}]
    $I_1 \FenceOrd I_2$ iff $I_1$ and $I_2$ both are memory or fence instructions, and $I_1 \ProgOrd I_2$, and $\OrderedFunc(I_1,I_2)$ is true.
\end{definition}


\noindent\textbf{Definition of preserved dependency order $<_{ppod}$ for GAM:}
We first give some basic definitions that are used to define dependency orderings precisely (all definitions ignore the PC register and the zero register): 
\begin{definition}[RS: Read Set]
    $RS(I)$ is the set of registers an instruction $I$ reads.
\end{definition}

\begin{definition}[WS: Write Set]
    $WS(I)$ is the set of registers an instruction $I$ can write.
\end{definition}

\begin{definition}[ARS: Address Read Set]
    $ARS(I)$ is the set of registers a memory instruction $I$ reads to
    compute the address of the memory operation.
\end{definition}

\begin{definition}[data-dependency $\DataDep$ \label{def:data-dep}]
    $I_1 \DataDep I_2$ if $I_1 \ProgOrd I_2$ and $WS(I_1) \cap
    RS(I_2) \neq \emptyset$ and there exists a register
    $r$ in $WS(I_1) \cap RS(I_2)$ such that there is no instruction
    $I$ such that $I_1 \ProgOrd I \ProgOrd I_2$ and $r \in WS(I)$.
\end{definition}

\begin{definition}[addr-dependency $\AddrDep$ \label{def:addr-dep}]
    $I_1 \AddrDep I_2$ if $I_1 \ProgOrd I_2$ and $WS(I_1) \cap
    ARS(I_2) \neq \emptyset$ and there exists a register
    $r$ in $WS(I_1) \cap ARS(I_2)$ such that there is no instruction
    $I$ such that $I_1 \ProgOrd I \ProgOrd I_2$ and $r \in WS(I)$.
\end{definition}

Note that data-dependency includes addr-dependency,
i.e., $I_1 \AddrDep I_2$ $\implies$ $I_1 \DataDep I_2$.


Now we define $\DepOrd$, which essentially says that the data-dependencies must be observed, stores should not execute until the preceding branches have been resolved, the execution of stores should be constrained by instructions on which prior memory instructions are
address dependent, and in the case of a load following a store to the same address, the execution of the load should be constrained by instructions which produce the store's data.

\begin{definition}[Preserved dependency order $\DepOrd$
\label{def:ppo-dep}]
    $I_1 \DepOrd I_2$ if either
    \begin{enumerate}
        \item \label{ppo:ddep} $I_1 \DataDep I_2$, or
        \item \label{ppo:br->st} $I_1 \ProgOrd I_2 $, and $I_1$ is a branch, and $I_2$ is a store, or
        \item \label{ppo:adep+po} $I_2$ is a store instruction, and there
        exists a memory instruction $I$ such that $I_1 \AddrDep I \ProgOrd I_2$,
        or
        \item \label{ppo:ddep+sa} $I_2$ is a load instruction, and there
        exists a store $S$ to the same address such that $I_1 \DataDep S
        \ProgOrd I_2$, and there is no other \emph{store} for the same
        address between $S$ and $I_2$.
    \end{enumerate}
\end{definition}


In the above definition, cases~\ref{ppo:ddep} and \ref{ppo:br->st} are straightforward; we discuss the rest of the cases below.

Case~\ref{ppo:adep+po} is about a subtle dependency caused by an address dependency and is illustrated by the example in
Figure~\ref{fig:adep-po-example}.  
If $I_3$ (store) is allowed to be issued before $I_1$, then the earlier load ($I_2$) may end up reading its own future store in case $I_1$ returns value $r_1=b$.

\begin{figure}[!htb]
    \centering
    \begin{tabular}{|l|}
        \hline
        $I_1:$ $r_1$ = Ld $a$\\
        $I_2:$ $r_2$ = Ld $r_1$\\
        $I_3:$ St $b$ = 1\\
        \hline
    \end{tabular}
    \caption{Example for case~\ref{ppo:adep+po}}\label{fig:adep-po-example}
\end{figure}

Case~\ref{ppo:ddep+sa} is about another subtle dependency when data is
transfered not by registers but by local bypassing.  In
Figure~\ref{fig:ddep-sa-example}, $I_3$ must be issued after $I_1$.
Otherwise, in case $I_3$ is issued before $I_1$, $I_3$ must bypass
from $I_2$.  However, the data of $I_2$ is still unknown at that time.
\begin{figure}[!htb]
    \centering
    \begin{tabular}{|l|}
        \hline
        $I_1:$ $r_1$ = Ld $a$ \\
        $I_2:$ St $b$ = $r_1$ \\
        $I_3:$ $r_2$ = Ld $b$ \\ 
        \hline
    \end{tabular}
    \caption{Example for case~\ref{ppo:ddep+sa}}\label{fig:ddep-sa-example}
\end{figure}

\noindent\textbf{Definition of preserved same-address order $\SameAddrOrd$ for GAM:}
Next we give the definition of $\SameAddrOrd$, which captures the orderings between memory instructions for the same address.
\begin{definition}[Preserved same-address order $\SameAddrOrd$\label{def:ppo-same-addr}]
    $I_1 \SameAddrOrd I_2$ if either
    \begin{enumerate}
        \item \label{ppo:ld->st} $I_1 \ProgOrd I_2$, and $I_1$ is a load and $I_2$ is
        a store to the same address, or
        \item \label{ppo:st->st} $I_1 \ProgOrd I_2$, and both $I_1$ and $I_2$ are store
        instructions for the same address, or
        \item \label{ppo:ld->ld} $I_1 <_{po} I_2$ and both $I_1$ and $I_2$ are load
        instructions for the same address with no intervening \emph{store} to the
        same address.
    \end{enumerate}
\end{definition}

The above definition explicitly excludes the enforcement of ordering of a store followed by a load to the same address.
Otherwise our model would be stricter than TSO in some cases.
Case~\ref{ppo:ld->ld} requires that loads for
the same address without store to the same address in between to be
issued in order. For example, all instructions in
Figure~\ref{fig:lda-lda-example} must be issued in order.

\begin{figure}[!htb]
  \centering
  \begin{tabular}{|l|}
    \hline
    $I_1:$ $r_1$ = Ld $a$ \\
    $I_2:$ $r_2$ = Ld ($b+r_1-r_1$) \\
    $I_3:$ $r_3$ = Ld $b$ \\
    $I_4:$ $r_4$ = Ld ($c+r_3-r_3$) \\
    \hline
  \end{tabular}
  \caption{Example for case~\ref{ppo:ld->ld}}\label{fig:lda-lda-example}
\end{figure}

It should be noted that the choice to enforce this same-address load-load ordering in GAM is kind of arbitrary, because we do not see any decisive argument to support either enforcing or relaxing this ordering.
On the one hand, implementations that execute loads for the the same address out of order will not violate single-thread correctness, and do not need the extra hardware to enforce this load-load ordering.
On the other hand, programmers may expect memory models to have the per-location SC property~\cite{cantin2003complexity}, i.e., all memory accesses for a single address appear to be sequentially consistent, and enforcing this same-address load-load ordering is an easy way to provide the per-location SC property.
The Alpha memory model~\cite{alpha1998} is the same as GAM in enforcing this ordering, while the RMO memory model~\cite{weaver1994sparc} chooses to relax this ordering completely.
In Section~\ref{sec:compare-rmo} programmers would like memory models to have the per-location SC property~\cite{cantin2003complexity}.
It should be noted that ARMv8.2 makes yet another choice in same-address load-load ordering which we will explain in Section~\ref{sec:compare-arm}.

Finally, we define $\PreservePO$ as the transitive closure of $\DepOrd$, $\SameAddrOrd$ and $\LSFOrd$.
\begin{definition}[Preserved program order $\PreservePO$\label{def:ppo}]
    $I_1 \PreservePO I_2$ if either
    \begin{enumerate}
        \item $I_1 \LSFOrd I_2$, or
        \item $I_1 \DepOrd I_2$, or
        \item $I_1 \SameAddrOrd I_2$, or
        \item \label{ppo:trans} there exists an instruction $I$ such that $I_1
        \PreservePO I$ and $I <_{ppo} I_2$.
    \end{enumerate}
\end{definition}


\subsubsection{Memory Axioms of GAM}

GAM has the following two axioms (the notation $\max_{mo}$ means to find the youngest instruction in $\MemOrd$):
\begin{itemize}
    \item \textbf{Axiom Inst-Order:} If $I_1 \PreservePO I_2$, then $I_1 \MemOrd I_2$.
    \item \textbf{Axiom Load-Value:}
    \begin{displaymath}
    \mathsf{St}\ a\ v \ReadFrom \mathsf{Ld}\ a \Rightarrow
    \mathsf{St}\ a\ v = \max_{mo}\{
    \mathsf{St}\ a\ v'\ |\ \mathsf{St}\ a\ v' \ProgOrd
    \mathsf{Ld}\ a\ \vee\ \mathsf{St}\ a\ v' \MemOrd \mathsf{Ld}\ a \}
    \end{displaymath}
\end{itemize}
The first axiom says that $\MemOrd$ must respect $\PreservePO$.
An interpretation of this axiom is that the local ordering constraints on executing two memory instructions in the processor must be preserved when these two memory accesses are performed globally.
The second axiom specifies the store that a load should read given $\MemOrd$ and $\ProgOrd$.
Intuitively, each store overshadows previous stores to the same address and thus, a load should not be able to read overshadowed values. 
The only complication is because of bypassing: a load may read one of its own store values before it is advertised, which means  a later load in other processors may still read the globally advertised store value in the memory.   
More precisely, the set of stores that are visible to a load consists of stores that either precede the load in $\ProgOrd$ or perform globally before the load does (i.e., precede the load in $\MemOrd$).
The store read by the load must be visible to the load, and cannot be overshadowed (in $\MemOrd$) by another store which is also visible to the load.


\subsection{An Operational Definition of GAM}
\label{sec:operational}

The operational model of GAM consists of $n$ processors $P_1\ldots P_n$ and a monolithic memory $m$.
Each processor $P_i$ consists of an ROB and a PC register.
The PC register contains the address of the next instruction to be fetched into ROB.
When an instruction is fetched, if the instruction is a branch, we predict the branch target address and update the PC register speculatively; otherwise we simply increment the PC register.
Each instruction in the ROB has a \emph{done} bit.
(We refer to an instruction as done if the
done bit is true, and as not done otherwise.)  Though
instructions that have been marked as done can be removed from the
ROB, we will not bother with this detail.

At each step of the execution one of the instructions marked as
not-done in the ROB of a processor $P_i$ is selected and executed and
(sometimes) marked as done. There is often a \emph{guard} condition
associated with the execution of an instruction, and an instruction
can be executed only if the guard is true. As will become clear soon
that sometimes the execution of an instruction cannot proceed even when its guard is true.

Our axiomatic model, permits very aggressive execution of load
instructions but it also requires that consecutive loads to the same address be done in
order.  If the operational model executed load instructions only when
the address for its preceding memory instructions were known, then we will not
be able to capture all the behaviors allowed by the axiomatic
model. Thus, in the operational model, we let a load execute even
before all the addresses of preceding memory instructions are known,
and then later kill a done load if an older memory instruction
happens to get the same address.  The kill of a load instruction
means that all the instruction younger than the killed load,
including that load itself, are discarded from the ROB, and the PC register is updated to make
instruction fetch begin by refetching the killed load instruction.

In order to implement these speculative loads, we need an additional
\emph{address-available} state bit in the ROB for each memory
instruction. This bit indicates when the address calculation has been
completed. Initially this bit is not set.
% unless the address is a constant.

We need to know if the source operands of an instruction are available
in order to execute the instruction.  If the operand is
specified as a source register $r$, then its availability is
determined by searching the ROB from the current instruction slot
towards older instructions until the first slot containing $r$ as the
destination register. (The search always terminates because we assume
that the ROB has been initialized with instructions that set initial register values).
If the slot containing the destination register is marked as
done then the operand is assumed to be available, otherwise not.

This operational model is also parametrized by the memory/fence ordering.
That is, it uses $\OrderedFunc$ function to control when a memory or fence instruction can be marked as done.

In the following we specify how to execute an instruction in the ROB
according to the preserved program order definition given in Section
\ref{sec:ppo}.  Each operational rule has a guard and a specified
action.
\begin{itemize}
    \item \textbf{Rule Fetch:} \\
    \emph{Guard:} True. \\
    \emph{Action:} Fetch a new instruction from the address stored in the PC register.
    Add the new instruction into the tail of ROB.
    If the new instruction is a branch, we predict the branch target address of the branch, update PC to be the predicted address, and record the predicted address in the ROB entry of the branch; otherwise we increment PC.
    
    \item \textbf{Rule Execute-Reg-to-Reg:} Execute a reg-to-reg instruction $I$. \\
    \emph{Guard:} $I$ is marked not-done and all source operands of $I$ are ready. \\
    \emph{Action:} Do the computation, record the result in the ROB slot, and mark $I$ as done.
    
    \item \textbf{Rule Execute-Branch:} Execute a branch instruction $I$. \\
    \emph{Guard:} $I$ is marked not-done and all source operands of $I$ are ready. \\
    \emph{Action:} Compute the branch target address and mark $I$ as done.
    If the computed target address is different from the previously predicted address (which is recorded in the ROB entry), then we kill all instructions which are younger than $I$ in the ROB (excluding $I$).
    That is, we remove those instructions from the ROB, and update the PC register to the computed branch target address.
    
    \item \textbf{Rule Execute-Fence:} Execute a fence instruction $I$. \\
    \emph{Guard:} $I$ is marked not-done, and for each older (memory or fence) instruction $I'$ such that $\OrderedFunc(I', I)$ is true, $I'$ is done. \\
    \emph{Action:} Mark $I$ as done.
    
    \item \textbf{Rule Execute-Load:} Execute a load instruction $I$ for address $a$. \\
    \emph{Guard:} $I$ is marked not-done, and the address-available bit is set to available, and for each older (memory or fence) instruction $I'$ such that $\OrderedFunc(I', I)$ is true, $I'$ is done.\\
    \emph{Action:} Search the ROB from $I$ towards the oldest instruction for the first not-done memory instruction with address $a$:
    \begin{enumerate}
        \item If a not-done load to $a$ is found then instruction $I$ cannot be executed, i.e., we do nothing.
        \item If a not-done store to $a$ is found then if the data for the store is ready, then execute $I$ by bypassing the data from the store, and mark $I$ as done; otherwise, $I$ cannot be executed.
        \item If nothing is found then execute $I$ by reading $m[a]$, and mark $I$ as done.
    \end{enumerate}
    
    \item \textbf{Rule Compute-Store-Data:} compute the data of a store instruction $I$. \\
    \emph{Guard:} the source registers for the data computation are ready. \\ 
    \emph{Action:} Compute the data of $I$ and record it in the ROB slot.
    
    \item \textbf{Rule Execute-Store:} Execute a store $I$ for address $a$. \\
    \emph{Guard:} $I$ is marked not-done and in addition all the following conditions must be true:
    \begin{enumerate}
        \item The address-available flag for $I$ is set,
        \item The data of $I$ is ready,
        \item For each older (memory or fence) instruction $I'$ such that $\OrderedFunc(I', I)$ is true, $I'$ is done,
        \item All older branch instructions are done,
        \item \label{guard:addr->st} All older loads and stores have their address-available flags set,
        \item All older loads and stores for address $a$ are done.
    \end{enumerate}
    \emph{Action:} Update $m[a]$ and mark $I$ as done.
    
    \item \textbf{Rule Compute-Mem-Addr:} Compute the address of a load or store instruction $I$. \\
    \emph{Guard:} The address-available bit is not set and the address operand is ready with value $a$\\
    \emph{Action:} We first set the address-available bit and record the address $a$ into the ROB entry of $I$.
    Then we search the ROB from $I$ towards the youngest instruction (excluding $I$) for the first memory instruction with address $a$. 
    If the instruction found is a done load, then we kill that load and all instructions that are younger than the load in the ROB.
    That is, we remove the load and all younger instructions from the ROB, and set the PC register to the instruction-fetch address of the load.
    Otherwise no instruction needs to be killed.
\end{itemize}


\subsection{Soundness: GAM Operational model $\subseteq$ GAM Axiomatic Model}\label{sec:op<axiom}

The goal is to show that for any execution of the operational model, we can construct $\langle \ProgOrd, \MemOrd, \ReadFrom\rangle$ which satisfies the GAM axioms and has the same program behavior as the operational execution.
To do this, we need to introduce some ghost states to the operational model, and show invariants that hold after every step in the operational model.

In the operational model, we assume there is a (ghost) global time which is incremented whenever a rule fires.
%% For a rule $R$, we use $ts(R)$ (i.e., the timestamp of rule $R$) to denote the global time right before $R$ fires.
We also assume each instruction $I$ in an ROB has the following ghost states which are accessed only in the proofs (all states start as $\top$):
\begin{itemize}
    \item $I.\DoneTS$: Records the current global time when a rule $R$ fires and marks $I$ as done.
    \item $I.\AddrTS$: Records the current global time for memory instruction $I$ when a Compute-Mem-Addr rule $R$ fires to compute the address of $I$.
    \item $I.\StDataTS$: Records the current global time for a store instruction $I$, when a Compute-Store-Data rule $R$ fires to compute the store data of $I$.
    \item $I.\FromSt$: Records the store read by $I$ if $I$ is a load.
    That is, the store is either the not-done store $I$ bypasses from or the done store with the maximum $\DoneTS$ among all done stores for $a$ when $I$ is marked as done.

%a store in the rule, then we record that store into $I.\FromSt$; %otherwise $I$ reads from the monolithic memory address $a$, we record %into $I.\FromSt$ 
\end{itemize}
In the final proof, we will use the states at the end of the operational execution to construct the axiomatic edges.
$\ProgOrd$ will be constructed by the order of instructions in ROB, $\ReadFrom$ will be constructed by the $\FromSt$ states of loads, and $\MemOrd$ will be constructed by the order of $\DoneTS$ timestamps of all memory instructions.

For convenience, we use $I.\LdVal$ to denote the load value if $I$ is a load, use $I.\MemAddr$ to denote the memory access address if $I$ is a memory instruction, and use $I.\StData$ to denote the store data if $I$ is a store.
These fields are $\top$ if the corresponding values are not available.

Given the model state at any time in the execution of the operational model, we can define the program order $\RobProgOrd$, data-dependency order $\RobDataDep$, address-dependency order $\RobAddrDep$, and a new relation $\RobNTPreservePO$ which is similar to the preserved program order. (we add suffix $rob$ to distinguish from the definitions in the axiomatic model):
\begin{itemize}
    \item $\RobProgOrd$: Instructions $I_1 \RobProgOrd I_2$ iff both $I_1$ and $I_2$ are in the same ROB and $I_1$ is older than $I_2$ in the ROB.
    \item $\RobDataDep$: $I_1 \RobDataDep I_2$ iff $I_1\RobProgOrd I_2$ and $I_2$ needs the result of $I_1$ as a source operand.
    \item $\RobAddrDep$: $I_1 \RobAddrDep I_2$ iff $I_1\RobProgOrd I_2$, and $I_2$ is a memory instruction, and $I_2$ needs the result of $I_1$ as a source operand to compute the memory address to access.
    \item $\RobNTPreservePO$: $I_1 \RobNTPreservePO I_2$ iff $I_1 \RobProgOrd I_2$ and at least one of the following conditions hold:
    \begin{enumerate}
        \item $I_1 \RobDataDep I_2$.
        \item $I_1$ is a branch, and $I_2$ is a store.
        \item $I_2$ is a store, and there exists a memory instruction $I$ such that $I_1\RobAddrDep I\RobProgOrd I_2$.
        \item $I_2$ is a load with $I_2.\MemAddr = a \neq \top$, and there exists a store $S$ with $S.\MemAddr = a$, and $I_1 \RobDataDep S \RobProgOrd I_2$, and there is no store $S'$ such that $S'.\MemAddr = a$ and $S \RobProgOrd S' \RobProgOrd I_2$.
        \item $I_1$ is a load with $I_1.\MemAddr = a \neq \top$, and $I_2$ is a store with $I_2.\MemAddr = a$.
        \item Both $I_1$ and $I_2$ are stores with $I_1.\MemAddr = I_2.\MemAddr = a \neq \top$.
        \item Both $I_1$ and $I_2$ are loads with $I_1.\MemAddr = I_2.\MemAddr = a \neq \top$, and there is no store $S$ such that $S.\MemAddr = a$ and $I_1 \RobProgOrd S \RobProgOrd I_2$.
        \item $\OrderedFunc(I_1, I_2)$ is true.
    \end{enumerate}
\end{itemize}
It should be noted that the way to compute $\RobNTPreservePO$ from $\RobProgOrd$ is almost the same as the way to compute $\PreservePO$ from $\ProgOrd$ except for two differences.
The first difference is that $\RobNTPreservePO$ is not made transitively closed; this is for simplifying the proof to some degree.
The second difference is that in case the definition needs the address of memory instructions, $\RobNTPreservePO$ ignores memory instructions which have not computed their addresses.
Since the address of every memory instruction will be computed at the end of the operational execution, the second difference will diminish by that time.
Since $\ProgOrd$ is defined by the $\RobProgOrd$ at the end of the operational execution,  $\PreservePO$ will be the transitive closure of $\RobNTPreservePO$ at the end of the operational execution.

With the above definitions, we give the invariants of any operation execution in Lemma~\ref{lem:rob:inv}.
Invariant~\ref{inv:rob:ppo} is a similar statement to the Inst-Order axiom, and will become exactly the same as that axiom at the end of the operational execution.
Invariants~\ref{inv:rob:addr} and \ref{inv:rob:st-data} captures the ordering effects of dependencies carried to the computation of memory address and store data.
Invariant~\ref{inv:rob:addr-st} captures guard~\ref{guard:addr->st} of the Execute-Store rule, and is also related to case~\ref{ppo:adep+po} of Definition~\ref{def:ppo-dep} for $\PreservePO$.
Invariant~\ref{inv:rob:kill-done-st} is an important property saying that stores are never written to the shared memory speculatively, so the model does not need any system-wide rollback.
Invariant~\ref{inv:rob:mem-val} constrains the current monolithic memory value.
Invariant~\ref{inv:rob:rf} constrains the store read by a load, and in particular, invariant~\ref{prop:rob:rf:done-max} will become the Load-Value axiom at the end of the operation execution.
The detailed proof can be found in Appendix~\ref{sec:gam_axi_contain_op}.
\begin{lemma}\label{lem:rob:inv}
    The following invariants hold during the execution of the operational model:
    \begin{enumerate}
        \item \label{inv:rob:ppo} If $I_1 \RobNTPreservePO I_2$ and $I_2.\DoneTS \neq \top$, then $I_1.\DoneTS \neq \top$ and $I_1.\DoneTS < I_2.\DoneTS$.
        \item \label{inv:rob:addr} If $I_1 \RobAddrDep I_2$ and $I_2.\AddrTS \neq \top$, then $I_1.\DoneTS \neq \top$ and $I_1.\DoneTS < I_2.\AddrTS$.
        \item \label{inv:rob:st-data} If $I_1 \RobDataDep I_2$, and not $I_1\RobAddrDep I_2$, and $I_2$ is a store, and $I_2.\StDataTS \neq \top$, then $I_1.\DoneTS \neq \top$ and $I_1.\DoneTS < I_2.\StDataTS$.
        \item \label{inv:rob:addr-st} If $I_1 \RobProgOrd I_2$, and $I_1$ is a memory instruction, and $I_2$ is a store, and $I_2.\DoneTS \neq \top$, then $I_1.\AddrTS \neq \top$ and $I_1.\AddrTS < I_2.\DoneTS$.
        \item \label{inv:rob:kill-done-st} We never kill a done store.
        \item \label{inv:rob:mem-val} For any address $a$, let $S$ be the store with the maximum $\DoneTS$ among all the done stores for address $a$.
        The monolithic memory value for $a$ is equal to $S.\StData$.
        \item \label{inv:rob:rf} For any done load $L$, let $S = L.\FromSt$ (i.e., $S$ is the store read by $L$).
        All of the following properties are satisfied:
        \begin{enumerate}
            \item \label{prop:rob:rf:no-kill} $S$ still exists in an ROB (i.e., S is not killed).
            \item \label{prop:rob:rf:addr-data} $S.\MemAddr = L.\MemAddr$ and $S.\StData = L.\LdVal$.
            \item \label{prop:rob:rf:done-no-st} If $S$ is done, then there is no not-done store $S'$ such that $S'.addr = a$ and $S'\RobProgOrd L$.
            \item \label{prop:rob:rf:done-max} If $S$ is done, then for any other done store $S'$ with $S'.\MemAddr = L.\MemAddr$, if $S'\RobProgOrd L$ or $S'.\DoneTS < L.\DoneTS$, then $S'.\DoneTS < S.\DoneTS$.
            \item \label{prop:rob:rf:not-done} If $S$ is not done, then $S\RobProgOrd L$, and there is no store $S'$ such that $S'.\MemAddr = L.\MemAddr$ and $S\RobProgOrd S'\RobProgOrd L$.
        \end{enumerate}
    \end{enumerate}
\end{lemma}

With the above invariants, we can finally prove the following soundness theorem.
\begin{theorem}
    GAM operational model $\subseteq$ GAM axiomatic model.
\end{theorem}
\begin{proof}
    For any execution of the operational model, at the end of the execution, all instructions must be done.
    We construct $\langle \ProgOrd, \MemOrd, \ReadFrom \rangle$ using the ending state of the operational execution as follows:
    \begin{itemize}
        \item $\ProgOrd$ is constructed as the order of instructions in each ROB.
        \item $\MemOrd$ is constructed by the ordering of $\DoneTS$, i.e., for two memory instructions $I_1$ and $I_2$, $I_1\MemOrd I_2$ iff $I_1.\DoneTS < I_2.\DoneTS$.
        \item $\ReadFrom$ is constructed by the $\FromSt$ fields, i.e., for a load $L$ and a store $S$, $S\ReadFrom L$ iff $S = L.\FromSt$.
    \end{itemize}
    Invariant~\ref{prop:rob:rf:addr-data} ensures that the constructed $\ReadFrom$ and $\ProgOrd$ are consistent with each other (e.g., it rules out the case that $\ReadFrom$ says a load should read a store with value 1, but $\ProgOrd$ says the load has value 2).
    
    Since all instructions are done at the end of execution, then invariant~\ref{prop:rob:rf:done-max} becomes the Load-Value axiom.
    Therefore, the constructed $\langle \ProgOrd, \MemOrd, \ReadFrom \rangle$ satisfy the Load-Value axiom.
    
    At the end of execution, invariant~\ref{inv:rob:ppo} becomes: if $I_1\RobNTPreservePO I_2$, then $I_1.\DoneTS < I_2.\DoneTS$.
    Note that the $\PreservePO$ computed from $\ProgOrd$ is actually the transitive closure of $\RobNTPreservePO$.
    Since instructions are totally ordered by $\DoneTS$ fields, we have if  $I_1\PreservePO I_2$, then $I_1.\DoneTS < I_2.\DoneTS$.
    Since $\MemOrd$ is defined by the order of $\DoneTS$ fields, the Inst-Order axiom is also satisfied.
\end{proof}


\subsection{Completeness: GAM Axiomatic model $\subseteq$ GAM Operational Model}\label{sec:axiom<op}
\begin{theorem}
    GAM axiomatic model $\subseteq$ GAM operational model.
\end{theorem}
\begin{proof}
    The goal is that for any legal axiomatic relations $\langle \ProgOrd, \MemOrd, \ReadFrom\rangle$ (which satisfy the GAM axioms), we can run the operational model to give the same program behavior.
    The strategy to run the operational model consists of two major phases.
    In the first phase, we only fire Fetch rules to fetch all instructions into all ROBs according to $\ProgOrd$.
    During the second phase, in each step we fire a rule that either marks an instruction as done or computes the address or data of a memory instruction.
    Which rule to fire in a step depends on the current state of the operational model and $\MemOrd$.
    Here we give the detailed algorithm that determines which rule to fire in each step:
    \begin{enumerate}
        \item If in the operational model there is a not-done reg-to-reg or branch instruction whose source registers are all ready, then we fire an Execute-Reg-to-Reg or Execute-Branch rule to execute that instruction.
        \item If the above case does not apply, and in the operational model there is a memory instruction, whose address is not computed but the source registers for the address computation are all ready, then we fire a Compute-Mem-Addr rule to compute the address of that instruction.
        \item If neither of the above cases applies, and in the operational model there is a store instruction, whose store data is not computed but the source registers for the data computation are all ready, then we fire a Compute-Store-Data rule to compute the store data of that instruction.
        \item If none of the above cases applies, and in the operational model there is a fence instruction and the guard of the Execute-Fence rule for this fence is ready, then we fire the Execute-Fence rule to execute that fence.
        \item \label{sim:mem} If none of the above cases applies, then we find the oldest instruction in $\MemOrd$, which is not-done in the operational model, and we fire an Execute-Load or Execute-Store rule to execute that instruction.
    \end{enumerate}
    Before giving the invariants, we give a definition related  to the ordering of stores for the same address.
    For each address $a$, all stores for $a$ are totally ordered by $\MemOrd$, and we refer to this total order of stores for $a$ as $<_{co}^a$.
    
    Now we show the invariants.
    After each step, we maintain the following invariants:
    \begin{enumerate}
        \item The order of instructions in each ROB in the operational model is the same as the $\ProgOrd$ of that processor in the axiomatic relations.
        \item \label{inv:result} The results of all the instructions that have been marked as done so far in the operational model are the same as those in the axiomatic relations.
        \item All the load/store addresses that have been computed so far in the operational model are the same as those in the axiomatic relations.
        \item All the store data that have been computed so far in the operational model are the same as those in the axiomatic relations.
        \item \label{inv:no-kill} No kill has ever happened in the operational model.
        \item For the rule fired in each step that we have performed so far, the guard of the rule is satisfied the at that step (i.e., the rule can fire).
        \item \label{inv:done} In each step that we have performed so far, if we fire a rule to execute an instruction (especially a load) in that step, the instruction must be marked as done by the rule.
        \item \label{inv:store} For each address $a$, the order of all the store updates on monolithic memory address $a$ that have happened so far in the operational model is a prefix of $<_{co}^a$.
    \end{enumerate}
    The detailed proof of the invariants can be found in Appendix~\ref{sec:gam_op_contain_axi}.
\end{proof}
