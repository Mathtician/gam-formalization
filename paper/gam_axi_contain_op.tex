\section{GAM Operational model $\subseteq$ GAM Axiomatic Model}\label{sec:gam_axi_contain_op}

\begin{lemma}\label{lem:rob:ppo}
For any operational model state, the following properties hold:
\begin{enumerate}
    \item If $I_1\RobProgOrd I_2$, then whether $I_1$ is ordered before $I_2$ in any of $\RobDataDep,\RobAddrDep,\RobNTPreservePO$ only depends on the states of $I_1$, $I_2$, and instructions between $I_1$ and $I_2$ in the ROB.
    \item If we add a new instruction to the end of an ROB, then changes in $\RobDataDep,\RobAddrDep,\RobNTPreservePO$ can only involve new edges pointing to the newly added instruction.
    \item If we mark a not-done non-branch instruction as done in an ROB, then there is no change in $\RobDataDep,\RobAddrDep,\RobNTPreservePO$.
    \item If we mark a not-done branch instruction as done in an ROB, then the changes in $\RobDataDep,\RobAddrDep,\RobNTPreservePO$ can only involve removing existing edges.
    \item If we compute the store data of a store in an ROB, then there is no change in $\RobDataDep,\RobAddrDep,\RobNTPreservePO$.
    \item If we compute the address of a memory instruction in an ROB, then the changes in $\RobDataDep,\RobAddrDep$ can only involve removing existing edges.
    \item If we compute the address of a load $L$ to be $a$ in an ROB, then the changes in $\RobNTPreservePO$ can only involve:
    \begin{enumerate}
        \item new edges pointing to $L$, and
        \item new edges from $L$, and
        \item removal of existing edges.
    \end{enumerate}
    \item If we compute the address of a store $S$ to be $a$ in an ROB, then the changes in $\RobNTPreservePO$ can only involve:
    \begin{enumerate}
        \item new edges point to $S$, and
        \item new edges starting from $S$, and
        \item new edges across $S$, and
        \item removal of existing edges.
    \end{enumerate}
\end{enumerate}
\end{lemma}
\begin{proof}
    The cases in the lemma can be proved easily one by one.
\end{proof}

\begin{lemma}
    The following invariants hold during the execution of the operational model:
    \begin{enumerate}
        \item \label{inv:rob:ppo} If $I_1 \RobNTPreservePO I_2$ and $I_2.\DoneTS \neq \top$, then $I_1.\DoneTS \neq \top$ and $I_1.\DoneTS < I_2.\DoneTS$.
        \item \label{inv:rob:addr} If $I_1 \RobAddrDep I_2$ and $I_2.\AddrTS \neq \top$, then $I_1.\DoneTS \neq \top$ and $I_1.\DoneTS < I_2.\AddrTS$.
        \item \label{inv:rob:st-data} If $I_1 \RobDataDep I_2$, and  not $I_1\RobAddrDep I_2$, and $I_2$ is a store, and $I_2.\StDataTS \neq \top$, then $I_1.\DoneTS \neq \top$ and $I_1.\DoneTS < I_2.\StDataTS$.
        \item \label{inv:rob:addr-st} If $I_1 \RobProgOrd I_2$, and $I_1$ is a memory instruction, and $I_2$ is a store, and $I_2.\DoneTS \neq \top$, then $I_1.\AddrTS \neq \top$ and $I_1.\AddrTS < I_2.\DoneTS$.
        \item \label{inv:rob:kill-done-st} We never kill a done store.
        \item \label{inv:rob:mem-val} For any address $a$, let $S$ be the store with the maximum $\DoneTS$ among all the done stores for address $a$.
        The monolithic memory value for $a$ is equal to $S.\StData$.
        \item \label{inv:rob:rf} For any done load $L$, let $S = L.\FromSt$ (i.e., $S$ is the store read by $L$).
        All of the following properties are satisfied:
        \begin{enumerate}
            \item \label{prop:rob:rf:no-kill} $S$ still exists in an ROB (i.e., S is not killed).
            \item \label{prop:rob:rf:addr-data} $S.\MemAddr = L.\MemAddr$ and $S.\StData = L.\LdVal$.
            \item \label{prop:rob:rf:done-no-st} If $S$ is done, then there is no not-done store $S'$ such that $S'.addr = a$ and $S'\RobProgOrd L$.
            \item \label{prop:rob:rf:done-max} If $S$ is done, then for any other done store $S'$ with $S'.\MemAddr = L.\MemAddr$, if $S'\RobProgOrd L$ or $S'.\DoneTS < L.\DoneTS$, then $S'.\DoneTS < S.\DoneTS$.
            \item \label{prop:rob:rf:not-done} If $S$ is not done, then $S\RobProgOrd L$, and there is no store $S'$ such that $S'.\MemAddr = L.\MemAddr$ and $S\RobProgOrd S'\RobProgOrd L$.
        \end{enumerate}
    \end{enumerate}
\end{lemma}
\begin{proof}
We now prove the invariants inductively.
That is, when rule $R$ fires in the operational model, we assume that all the invariants hold before $R$ fires, and try to prove that the invariants still hold after $R$ fires.
To avoid confusion, we add superscript 0 to model states and orderings before $R$ fires, and add superscript 1 to model states and orderings after $R$ fires.
For example, $\RobNTPreservePO^0$ denotes the non-transitive preserved program order before $R$ fires, while $I.\DoneTS^1$ denotes the done timestamp of instruction $I$ after $R$ fires.
Consider the type of rule $R$:
\begin{enumerate}
    \item Fetch: Assume $R$ fetches a new instruction $I$ into an ROB.
    According to Lemma~\ref{lem:rob:ppo}, new edges in $\RobDataDep^1, \RobAddrDep^1, \RobNTPreservePO^1$ must point to $I$.
    Now we consider each invariant:
    \begin{itemize}
        \item Invariants~\ref{inv:rob:ppo}, \ref{inv:rob:addr} and \ref{inv:rob:st-data}:
        These invariants may be affected by the new edges in $\RobDataDep^1, \RobAddrDep^1, \RobNTPreservePO^1$.
        However, since $I.\DoneTS^1$, $I.\AddrTS^1$ and $I.\StDataTS^1$ are all $\top$, these invariants cannot be affected.
        
        \item Invariants~\ref{inv:rob:addr-st}, \ref{inv:rob:kill-done-st}, \ref{inv:rob:mem-val}, \ref{inv:rob:rf}: These invariants cannot be affected.
    \end{itemize}
    
    
    \item Execute-Reg-to-Reg: Assume $R$ executes a reg-to-reg instruction $I$ and marks it as done.
    According to Lemma~\ref{lem:rob:ppo}, $\RobDataDep^1, \RobAddrDep^1, \RobNTPreservePO^1$ are the same as $\RobDataDep^0, \RobAddrDep^0, \RobNTPreservePO^0$, respectively.
    $I.\DoneTS$ changes from $\top$ to current global time.
    Now we consider each invariant:
    \begin{itemize}
        \item Invariant~\ref{inv:rob:ppo}: This invariant can be affected by the change in $I.\DoneTS$.
        Consider any $I_1$ such that $I_1 \RobNTPreservePO^1 I$.
        Since $I$ is a reg-to-reg instruction, it must be that $I_1\RobDataDep^1 I$ according to the definition of $\RobNTPreservePO$.
        Since $\RobDataDep^0 = \RobDataDep^1$, $I_1\RobDataDep^0 I$.
        The guard of $R$ requires that $I_1$ is already done before $R$ fires, so $I_1.\DoneTS^1 = I_1.\DoneTS^0 < I.\DoneTS^1$, i.e., the invariant still holds.
        
        \item Invariants~\ref{inv:rob:addr}, \ref{inv:rob:st-data}, \ref{inv:rob:addr-st}, \ref{inv:rob:kill-done-st}, \ref{inv:rob:mem-val}, \ref{inv:rob:rf}: These invariants cannot be affected.
    \end{itemize}
    
    
    \item Execute-Branch: Assume $R$ executes a branch instruction $I$ and marks it as done.
    According to Lemma~\ref{lem:rob:ppo}, $\RobDataDep^1, \RobAddrDep^1, \RobNTPreservePO^1$ are contained by $\RobDataDep^0, \RobAddrDep^0, \RobNTPreservePO^0$, respectively. 
    $I.\DoneTS$ changes from $\top$ to current global time, and instructions younger than $I$ in the ROB may all be killed.
    Now we consider each invariant:
    \begin{enumerate}
        \item Invariant~\ref{inv:rob:ppo}:
        Consider any $I_1$ such that $I_1\RobNTPreservePO^1 I$.
        Since $I$ is a branch, it must be that $I_1\RobDataDep^1 I$.
        Since $\RobDataDep^1 \subseteq \RobDataDep^0$, $I_1\RobDataDep^0 I$.
        The guard of $R$ ensures that $I_1$ must be already done right before $R$ fires, so $I_1.\DoneTS^1 = I_1.\DoneTS^0 < I.\DoneTS^1$, i.e., the invariant still holds.
        
        \item Invariants~\ref{inv:rob:addr}, \ref{inv:rob:st-data}, \ref{inv:rob:addr-st}: These invariants cannot be affected.
        
        \item Invariant~\ref{inv:rob:kill-done-st}:
        This invariant may be affected if instructions are killed.
        We prove by contradiction, i.e., we assume a done store $S$ is killed in rule $R$.
        Since $S$ is killed, $I\RobProgOrd^0 S\Rightarrow I\RobNTPreservePO^0 S$.
        According to invariant~\ref{inv:rob:ppo}, $S.\DoneTS^0 \neq \top \Rightarrow I.\DoneTS^0 \neq \top$, i.e., $I$ is done even before $R$ fires.
        This contradicts with the guard of $R$.
        
        \item Invariant~\ref{inv:rob:mem-val}: This invariant cannot be affected.
        
        \item Invariant~\ref{inv:rob:rf}: 
        We consider each case in this invariant:
        \begin{itemize}
            \item Invariant~\ref{prop:rob:rf:no-kill}: This invariant can be affected by instruction kills.
            Assume a store $S$ is killed by $I$ in rule $R$ ($I\RobProgOrd^0 S$), and $S$ is read by a load $L$ (i.e., $S = L.\FromSt$).
            We have shown that $S$ cannot be done, so $S$ is not done before $R$ fires.
            Invariant~\ref{prop:rob:rf:not-done} says that $S\RobProgOrd^0 L$.
            Then $L$ will also be killed by $I$, so this invariant still holds.
            
            \item Invariants~\ref{prop:rob:rf:addr-data}, \ref{prop:rob:rf:done-no-st}, \ref{prop:rob:rf:done-max}, \ref{prop:rob:rf:not-done}: These invariants cannot be affected.
        \end{itemize}
    \end{enumerate}
    
    
    \item Execute-Fence: Assume $R$ executes a fence instruction $F$ and marks it as done.
    According to Lemma~\ref{lem:rob:ppo}, $\RobDataDep^1, \RobAddrDep^1, \RobNTPreservePO^1$ are the same as $\RobDataDep^0, \RobAddrDep^0, \RobNTPreservePO^0$, respectively.
    $I.\DoneTS$ changes from $\top$ to current global time.
    Now we consider each invariant:
    \begin{itemize}
        \item Invariant~\ref{inv:rob:ppo}: This invariant can be affected by the change in $I.\DoneTS$.
        Consider any $I_1$ such that $I_1 \RobNTPreservePO^1 F$.
        Since $\RobNTPreservePO^0 = \RobNTPreservePO^1$, $I_1 \RobNTPreservePO^0 F$.
        Since $F$ is a fence, it must be that $\OrderedFenceFunc(I_1, F)$ is true before $R$ fires.
        Then the guard of $R$ ensures that $I_1$ must be already done before $R$ fires, so $I_1.\DoneTS^1 = I_1.\DoneTS^0 < F.\DoneTS^1$, i.e., the invariant still holds.
        
        \item Invariants~\ref{inv:rob:addr}, \ref{inv:rob:st-data}, \ref{inv:rob:addr-st}, \ref{inv:rob:kill-done-st}, \ref{inv:rob:mem-val}, \ref{inv:rob:rf}: These invariants cannot be affected.
    \end{itemize} 
    
    
    \item Compute-Store-Data: Assume $R$ computes the data of a store $S$.
    According to Lemma~\ref{lem:rob:ppo}, $\RobDataDep^1, \RobAddrDep^1, \RobNTPreservePO^1$ are the same as $\RobDataDep^0, \RobAddrDep^0, \RobNTPreservePO^0$, respectively.
    $S.\StDataTS$ changes from $\top$ to current global time.
    Now we consider each invariant:
    \begin{itemize}
        \item Invariants~\ref{inv:rob:ppo}, \ref{inv:rob:addr}: These invariant cannot be affected.
        
        \item Invariant~\ref{inv:rob:st-data}:
        Consider any instruction $I_1$ such that $I_1 \RobDataDep^1 S$ but not $I_1\RobAddrDep^1 S$.
        Note that $\RobDataDep^0 = \RobDataDep^1$ and $\RobAddrDep^0 = \RobAddrDep^1$.
        Therefore, the computation of the data of $S$ uses the result of $I_1$ as a source operand.
        Then the guard of $R$ ensures that $I_1$ must be already done before $R$ fires.
        Therefore, we have $I_1.\DoneTS^1 = I_1.\DoneTS^0 < S.\StDataTS^1$, and the invariant still holds.
        
        \item Invariants~\ref{inv:rob:addr-st}, \ref{inv:rob:kill-done-st}, \ref{inv:rob:mem-val}: These invariant cannot be affected.
        
        \item Invariant~\ref{inv:rob:rf}:
        If there exists a done load $L$ such that $L.\FromSt^0 = S$, then $S.\StData^0 \neq \top$ according to invariant~\ref{prop:rob:rf:addr-data}.
        That is, the store data of $S$ is already computed before $R$ fires, contradicting with the guard of $R$.
        Therefore, $S$ is not read by any load yet, and this invariant is not affected.
    \end{itemize}
   
    
    \item Execute-Store: Assume $R$ executes a store $S$ and marks it as done.
    According to Lemma~\ref{lem:rob:ppo}, $\RobDataDep^1, \RobAddrDep^1, \RobNTPreservePO^1$ are the same as $\RobDataDep^0, \RobAddrDep^0, \RobNTPreservePO^0$, respectively.
    $S.\DoneTS$ changes from $\top$ to current global time, and the monolithic memory is also updated.
    Now we consider each invariant:
    \begin{itemize}
        \item Invariant~\ref{inv:rob:ppo}: This invariant can be affected by the change in $S.\DoneTS$.
        Consider any $I_1$ such that $I_1\RobNTPreservePO^1 S$.
        Since $\RobNTPreservePO^0 = \RobNTPreservePO^1$, $I_1\RobNTPreservePO^0 S$.
        Since $S$ is a store, there can following cases to form $I_1\RobNTPreservePO^0 S$:
        \begin{itemize}
            \item $I_1\DataDep^0 S$: 
            The guard of $R$ ensures that $\max(S.\AddrTS^0, S.\StDataTS^0) < S.\DoneTS^1$.
            Invariants~\ref{inv:rob:addr} and \ref{inv:rob:st-data} says that $I_1.\DoneTS^0 < \max(S.\AddrTS^0, S.\StDataTS^0)$.
            Thus, we have $I_1.\DoneTS^1 = I_1.\DoneTS^0 < S.\DoneTS^1$, i.e., the invariant still holds.
            
            \item $I_1$ is a branch: The guard of $R$ ensures that $I$ is already done before $R$ fires, so $I_1.\DoneTS^1 = I_1.\DoneTS^0 < S.\DoneTS^1$, i.e., the invariant still holds.
            
            \item There exists a memory instruction $I$ such that $I_1 \RobAddrDep^0 I\RobProgOrd^0 S$:
            The guard of $R$ ensures that the address of $I$ has been computed before $R$ fires, i.e., $I.\AddrTS^0 < S.\DoneTS^1$.
            Invariant~\ref{inv:rob:addr} says that $I_1.\DoneTS^0 < I.\AddrTS^0$.
            Thus, $I_1.\DoneTS^1 = I_1.\DoneTS^0 < S.\DoneTS^1$, i.e., the invariant still holds.
            
            \item $I_1$ is a load whose address has been computed to the same as the address of $S$:
            The guard of $R$ ensures that $I$ is done before $R$ fires,  so $I_1.\DoneTS^1 = I_1.\DoneTS^0 < S.\DoneTS^1$, i.e., the invariant still holds.
            
            \item $I_1$ is a store whose address has been computed to the same as the address of $S$:
            The guard of $R$ ensures that $I$ is done before $R$ fires,  so $I_1.\DoneTS^1 = I_1.\DoneTS^0 < S.\DoneTS^1$, i.e., the invariant still holds.
            
            \item $\OrderedFunc(I_1, S)$ is true:
            The guard of $R$ ensures that $I$ is done before $R$ fires, so $I_1.\DoneTS^1 = I_1.\DoneTS^0 < S.\DoneTS^1$, i.e., the invariant still holds.  
        \end{itemize}
        
        \item Invariants~\ref{inv:rob:addr}, \ref{inv:rob:st-data}: These invariants are not affected.
        
        \item Invariants~\ref{inv:rob:addr-st}: This invariant can be affected by the change in $S.\DoneTS$.
        Consider any memory instruction $I_1$ such that $I_1\RobProgOrd^1 I_2$.
        Note that $\RobProgOrd$ cannot be changed by $R$, so $I_1\RobProgOrd^0 I_2$.
        The guard of $R$ ensures that $I_1$ has computed its address before $R$ fires, so $I_1.\AddrTS^1 = I_1.\AddrTS^0 < S.\DoneTS^1$, i.e., the invariant still holds.
        
        \item Invariant~\ref{inv:rob:kill-done-st}: This invariant is not affected.
        
        \item Invariant~\ref{inv:rob:mem-val}: This invariant can be affected by making $S$ done and updating the monolithic memory.
        We only need to focus on memory address $a = S.\MemAddr^0$; other addresses are not affected.
        Note that $S.\DoneTS^1$ is the maximum among the non-$\top$ $\DoneTS$ of every instruction.
        Therefore, after $R$ fires, $S$ is the store with the maximum $\DoneTS$ among all done stores for $a$.
        On the other hand, the monolithic memory location $a$ is updated to $S.\StData$ by rule $R$.
        Thus, the invariant still holds.
        
        \item Invariant~\ref{inv:rob:rf}:
        We assume $a = S.\MemAddr$.
        We consider each case in this invariant:
        \begin{itemize}
            \item Invariant~\ref{prop:rob:rf:no-kill}, \ref{prop:rob:rf:addr-data}: These invariants are not affected.
            
            \item Invariant~\ref{prop:rob:rf:done-no-st}: This invariant can be affected when there exists a done load $L$ such that $L.\FromSt^0 = S$.
            We need to show that there is no not-done store $S'$ such that $S'.\MemAddr^1 = a$ and $S'\RobProgOrd^1 L$.
            Since rule does not compute any address or change $\RobProgOrd$.
            It is equivalent to show that there is no not-done store $S'$ such that $S'.\MemAddr^0 = a$ and $S'\RobProgOrd^0 L$.
            We prove by contradiction, i.e., we assume such $S'$ exists before $R$ fires.
            Since $S$ is not done before $R$ fires, according to invariant~\ref{prop:rob:rf:not-done}, $S \RobProgOrd^0 L$ and it cannot be that $S\RobProgOrd^0 S' \RobProgOrd^0 L$.
            Thus, it must be that $S'\RobProgOrd S$.
            However, the guard of $R$ requires that $S'$ to be done bofore $R$ fires, contradicting with the assumption that $S'$ is not done.
            Thus, the invariant holds.
            
            \item Invariant~\ref{prop:rob:rf:done-max}: This invariant can be affected in the following two ways:
            \begin{enumerate}
                \item There exists a done load $L$ such that $L.\FromSt^0 = S$:
                In this case, we need to show that for any other done store $S'$ with $S'.\MemAddr^1 = a$, if $S'\RobProgOrd^1 L$ or $S'.\DoneTS^1 < L.\DoneTS^1$, then $S'.\DoneTS^1 < S.\DoneTS^1$.
                Since $S.\DoneTS^1$ is the maximum $\DoneTS$ among all done instructions, this invariant still holds.
                
                \item There exists a done load $L^*$ and a done store $S^*$ such that $L^*.\FromSt^1 = S^*$ and $L^*.\MemAddr^1 = S^*.\MemAddr^1 = S^*$:
                In this case, we need to show that if $S\RobProgOrd^1 L^*$ or $S.\DoneTS^1 < L^*.\DoneTS^1$, then $S.\DoneTS^1 < S^*.\DoneTS^1$.
                Since $S.\DoneTS^1$ is the maximum, $S.\DoneTS^1 < L^*.\DoneTS^1$ must be false.
                We will now show that $S\RobProgOrd^1 L^*$ is also impossible to prove the invariant holds.
                We prove it by contradiction, i.e., we assume $S\RobProgOrd^1 L^*$.
                Since rule $R$ does not change $\RobProgOrd$ or any store address or any state of $L^*$ and $S^*$, we have $S\RobProgOrd^0 L^*$, $S.\MemAddr^0 = a = L^*.\MemAddr^* = S^*.\MemAddr^0$, $L^*.\FromSt^0 = S^*$, and $S^*$ is done before $R$ fires.
                This contradicts with Invariant~\ref{prop:rob:rf:done-no-st}.
                Therefore, the invariant still holds.
            \end{enumerate}
            
            \item Invariant~\ref{prop:rob:rf:not-done}: This invariant is not affected.
        \end{itemize}
    \end{itemize}
    
    \item Execute-Load: Assume $R$ executes a load $L$.   
    If $L$ is not marked as done, the model state does not change, so all invariants still hold.
    Now we consider the case that $L$ is marked as done.
    According to Lemma~\ref{lem:rob:ppo}, $\RobDataDep^1, \RobAddrDep^1, \RobNTPreservePO^1$ are the same as $\RobDataDep^0, \RobAddrDep^0, \RobNTPreservePO^0$, respectively.
    $L.\DoneTS$ changes from $\top$ to current global time.
    Now we consider each invariant:
    \begin{itemize}
        \item Invariant~\ref{inv:rob:ppo}: This invariant can be affected by the change in $L.\DoneTS$.
        Assume $a = L.\MemAddr^0$.
        Consider any $I_1$ such that $I_1\RobNTPreservePO^1 L$.
        Since $\RobNTPreservePO$ is not changed by $R$, we have $I_1\RobNTPreservePO^0 L$.
        This ordering can be caused by the following cases:
        \begin{itemize}
            \item $I_1\DataDep^0 L$: Since $L$ only needs to compute the address from registers, $I_1\AddrDep^0 L$.
            Invariant~\ref{inv:rob:addr} says that $I_1.\DoneTS^0 < I_1.\AddrTS^0$.
            The guard of $R$ ensures that $L.\AddrTS^0 < L.\DoneTS^1$.
            Therefore $I_1.\DoneTS^1 = I_1.\DoneTS^0 < L.\DoneTS^1$, i.e., the invariant still holds.
                          
            \item There exists a store $S$ such that $S.\MemAddr^1 = a$ and $I_1 \RobDataDep^1 S\RobProgOrd^1 L$, and there is no store $S'$ such that $S'.\MemAddr^1 = a$ and $S \RobProgOrd^1 S' \RobProgOrd^1 L$:
            Since $R$ does not change $\RobProgOrd$, $\RobDataDep$ or any address, the above condition becomes: $S.\MemAddr^0 = a$, and $I_1\RobDataDep^0 S\RobProgOrd L$, and there is no store $S'$ such that $S'.\MemAddr^0 = a$ and $S \RobProgOrd^0 S' \RobProgOrd^0 L$.
            Before $R$ fires, if there are not-done loads with computed addresses $a$ between $S$ and $L$ in the ROB, then let $L'$ be the youngest of them in ROB, and the ROB search conducted in $R$ will stop at $L'$.
            This will make $R$ not mark $L$ as done, contradicting with our previous assumption.
            Therefore, right before $R$ fires, any load with computed address $a$ between $S$ and $L$ in the ROB must be done.
            Since $S.\MemAddr^0 = a$, the ROB search in $R$ will search through $S$.
            If $S.\StDataTS^0 = \top$, then the ROB search will stop at $S$ and $L$ cannot be marked as done, contradicting with our assumption.
            Therefore, $S.\StDataTS\neq \top \Rightarrow S.\StDataTS^0 < L.\DoneTS^1$.
            Since address of $S$ is computed before $R$ fires, $S.\AddrTS^0 < L.\DoneTS^1$.
            Invariants~\ref{inv:rob:addr} and \ref{inv:rob:st-data} say that $I_1.\DoneTS^0 < \max(S.\AddrTS^0, S.\StDataTS^0)$, so $I_1.\DoneTS^1 = I_1.\DoneTS^0 < L.\DoneTS^1$, i.e., the invariant still holds.
            
            \item $I_1$ is a load with $I_1.\MemAddr^1 = a$, and there is no store $S$ such that $S.\MemAddr^1 = a$ and $I_1 \RobProgOrd^1 S \RobProgOrd^1 L$:
            Since $R$ does not change $\RobProgOrd$ or any address, the above condition becomes: $I_1.\MemAddr^0 = a$, and there is no store $S$ such that $S.\MemAddr^0 = a$ and $I_1 \RobProgOrd^0 S \RobProgOrd^1 L$.
            Before $R$ fires, if there are not-done loads with computed addresses $a$ between $I_1$ and $L$ in the ROB, then let $L'$ be the youngest of them in ROB, and the ROB search conducted in $R$ will stop at $L'$.
            This will make $R$ not mark $L$ as done, contradicting with our previous assumption.
            Therefore, right before $R$ fires, any load with computed address $a$ between $I_1$ and $L$ in the ROB must be done.
            Since $I_1.\MemAddr = a$, the ROB search in $R$ will search through $S$.
            If $I_1$ is not done before $R$ fires, then the ROB search will stop at $L$ and $L$ cannot be marked as done in $R$, contradicting with our previous assumption.
            Therefore $I_1$ is done before $R$ fires, so $I_1.\DoneTS^1 = I_1.\DoneTS^0 < L.\DoneTS^1$, i.e., the invariant still holds.
            
            \item $\OrderedFunc(I_1,L)$ is true:
            The guard of $R$ ensures that $I$ is done before $R$ fires, so $I_1.\DoneTS^1 = I_1.\DoneTS^0 < S.\DoneTS^1$, i.e., the invariant still holds.
        \end{itemize}
        
        \item Invariants~\ref{inv:rob:addr}, \ref{inv:rob:addr-st}, \ref{inv:rob:st-data}, \ref{inv:rob:kill-done-st}, \ref{inv:rob:mem-val}: These invariants cannot be affected.
        
        \item Invariant~\ref{inv:rob:rf}: This invariant can be affected because $L$ becomes done.
        Let $S = L.\FromSt^1$, and let $a = L.\MemAddr^1$.
        We need to show that $L$ and $S$ satisfies all the sub-invariants.
        We consider each case of separately.
        \begin{itemize}
            \item Invariant~\ref{prop:rob:rf:no-kill}: This invariant cannot be affected.
            
            \item Invariant~\ref{prop:rob:rf:addr-data}: We need to show that $S.\MemAddr^1 = L.\MemAddr^1$ ad $S.\StData^1 = L.\LdVal^1$.
            Note that $S.\MemAddr^0 = S.\MemAddr^0 = L.\MemAddr^0 = L.\MemAddr^1$.
            Also note that $S.\StData^0 = S.\StData^1$ and $L.\LdVal$ is the value read in rule $R$.
            If $L$ bypasses from local store in ROB, then $S$ is the store being bypassed, and the invariant holds.
            Otherwise, $L$ reads from monolithic memory, and invariant~\ref{inv:rob:mem-val} ensures that invariant holds.
            
            \item Invariant~\ref{prop:rob:rf:done-no-st}: Since $S$ is done after $R$ fires, $S$ is also done before $R$ fires.
            Then $R$ reads the value from monolithic memory.
            The guard of $R$ ensures that there is no store $S'$ such that $S'.\MemAddr^0 = a$ and $S'\RobProgOrd^0 L$.
            Since $R$ does not change address or $\RobProgOrd$, the invariant still holds.
            
            \item Invariant~\ref{prop:rob:rf:done-max}: Using the same argument as above, $R$ reads the value from monolithic memory.
            Right before $R$ fires, invariant~\ref{inv:rob:mem-val} says that for any other done store $S'$ with $S'.\MemAddr^0 = a$, $S'.\DoneTS < S.\DoneTS$.
            Since $R$ does not change $\DoneTS$ of stores or address, the invariant still holds.
            
            \item Invariant~\ref{prop:rob:rf:not-done}: Since $S.\DoneTS^1 = \top$, $S.\DoneTS^0 = \top$.
            Then $R$ reads the value by bypassing from $S$ in the local ROB, i.e., the ROB search in $R$ stops at $S$.
            We now prove by contradiction, i.e., we assume there exists $S'$ with $S'.\MemAddr^1 = a$ and $S\RobProgOrd^1 S' \RobProgOrd^1 L$.
            Since $R$ does not change address or $\RobProgOrd$, $S'.\MemAddr^0 =a$ and $S\RobProgOrd^0 S' \RobProgOrd^0 L$.
            Since $S\RobNTPreservePO^0 S'$, invariant~\ref{inv:rob:ppo} says that $S'.\DoneTS^0 = \top$.
            Then the ROB search cannot stop at $S$, contradicting with our previous conclusion.
            Therefore the invariant still holds.
        \end{itemize}
    \end{itemize}
    
    \item Compute-Mem-Addr for load $L$: $R$ computes the address of load $L$ to $a$.
    According to Lemma~\ref{lem:rob:ppo}, edges in $\RobDataDep$ and $\RobAddrDep$ may reduce.
    Some edges in $\RobNTPreservePO$ may be removed, but there can also be new $\RobNTPreservePO$ edges.
    $L.\MemAddr$ changes from $\top$ to $a$.
    We consider each invariant separately.
    \begin{itemize}
        \item Invariant~\ref{inv:rob:ppo}:
        Since $L$ is not done, we only need to consider newly generated $\RobNTPreservePO$ edges that start from $L$.
        Consider any $I_2$ such that $L\RobNTPreservePO^1 I_2$ but not $L\RobNTPreservePO^0 I_2$.
        We need to show that $I_2.\DoneTS^1 = \top$.
        $I_2$ must be in the following cases:
        \begin{itemize}
            \item $I_2$ is a store, $L\RobProgOrd^1 I_2$, and $I_2.\MemAddr^1 = a$:
            We prove by contradiction, i.e., assume $I_2.\DoneTS^1 \neq \top$.
            This gives $I_2.\DoneTS^0 \neq \top$.
            Since $L\RobProgOrd^0 S$ and $L.\AddrTS^0 = \top$, invariant~\ref{inv:rob:addr} says that $I_2.\DoneTS^0 = \top$, contradicting with previous assumption.
            Therefore the invariant still holds.
            
            \item $I_2$ is a load, $L\RobProgOrd^1 I_2$, $I_2.\MemAddr^1 = a$, and there is no store $S$ such that $S.\MemAddr^1 = a$ and $L\RobProgOrd^1 S\RobProgOrd^1 I_2$:
            We prove by contradiction, i.e., assume $I_2.\DoneTS^1 \neq \top$.
            This implies that $I_2$ is also done before $R$ fires.
            Since the ROB search in $R$ does not kill $I_2$, there must be a not-done load $L'$ such that $L'.\MemAddr^0 = a$ and $L\RobProgOrd^0 L' \RobProgOrd^0 I_2$.
            Now we have $L'\RobNTPreservePO I_2$.
            Since $L'.\DoneTS = \top$, this contradicts with invariant~\ref{inv:rob:ppo}.
            Therefore the invariant still holds.
        \end{itemize}
        
        \item Invariant~\ref{inv:rob:addr}: The guard of $R$ ensures that this invariant still holds.
        
        \item Invariants~\ref{inv:rob:st-data}, \ref{inv:rob:addr-st}: These invariants cannot be affected.
        
        \item Invariant~\ref{inv:rob:kill-done-st}: We prove by contradiction, i.e., we assume a done store $S$ is killed.
        Note that $S.\DoneTS^0 = S.\DoneTS^1 \neq \top$ and $L\RobProgOrd^0 S$.
        Invariant~\ref{inv:rob:addr-st} says that $L.\AddrTS^0 \neq \top$, contradicting with the guard of $R$.
        Therefore the invariant still holds.
        
        \item Invariants~\ref{inv:rob:mem-val} and \ref{inv:rob:rf}: These invariants cannot be affected.
    \end{itemize}
    
    
    \item Compute-Mem-Addr for store $S$: $R$ computes the address of $S$ to be $a$.
    According to Lemma~\ref{lem:rob:ppo}, edges in $\RobDataDep$ and $\RobAddrDep$ may reduce.
    Some edges in $\RobNTPreservePO$ may be removed, but there can also be new $\RobNTPreservePO$ edges.
    $S.\MemAddr$ changes from $\top$ to $a$.
    We consider each invariant separately.
    \begin{itemize}
        \item Invariant~\ref{inv:rob:ppo}:
        Since $S$ is not done, we do not need to consider new $\RobNTPreservePO$ edges ending at $S$.
        We only need to consider new $\RobNTPreservePO$ edges starting from $S$ or across $S$.
        There are the following two cases:
        \begin{itemize}
            \item There is store $S'$ such that $S'.\MemAddr^1 = a$ and $S\RobProgOrd^1 S'$:
            We need to show that $S'.\DoneTS^1 = \top$.
            We prove by contradiction, i.e., we assume $S'.\DoneTS^1 \neq \top$.
            This implies $S'.\DoneTS^0 \neq \top$ and $S\RobProgOrd^0 S'$.
            According to invariant~\ref{inv:rob:addr-st}, $S.\MemAddr^0 \neq \top$, contradicting with the guard of $R$.
            
            \item There is instruction $I_1$ and load $L$ such that $L.\MemAddr^1 = a$ and $I_1\RobDataDep^1 S\RobProgOrd^1 L$, and there is no store $S'$ such that $S'.\MemAddr^1=a$ and $S\RobProgOrd^1 S'\RobProgOrd^1 L$:
            The above statement becomes: $L.\MemAddr^0 = a$, $I_1\RobDataDep^0 S\RobProgOrd^0 L$, and there is not store $S'$ such that $S'.\MemAddr^0 = a$ and $S\RobProgOrd^0 S'\RobProgOrd^0 L$.
            We can show that $L.\DoneTS^1 = \top$, so the invariant still holds.
            We prove by contradiction, i.e., $L.\DoneTS^1\neq \top$.
            This implies $L.\DoneTS^0\neq \top$.
            Since $S$ is not killed by the ROB search in $R$, there must be $L'$ such that $L'.\MemAddr^0 = a$, $L'.\DoneTS^0 = \top$ and $S\RobProgOrd^0 L'\RobProgOrd^0 L$.
            This gives $L'\RobNTPreservePO^0 L$.
            Since $L.\DoneTS^0\neq \top$, this contradicts invariant~\ref{inv:rob:ppo}.
        \end{itemize}
        
        \item Invariant~\ref{inv:rob:addr}: The guard of $R$ ensures that this invariant still holds.
        
        \item Invariants~\ref{inv:rob:st-data}, \ref{inv:rob:addr-st}: These invariant cannot be affected.
        
        \item Invariant~\ref{inv:rob:kill-done-st}: We prove by contradiction, i.e., we assume a done store $S'$ is killed.
        That is, $S'.\DoneTS^0 \neq \top$ and $S\RobProgOrd^0 S'$.
        Invariant~\ref{inv:rob:addr-st} says that $S.\MemAddr^0 \neq \top$, contradicting with the guard of $R$.
        
        \item Invariant~\ref{inv:rob:mem-val}: This invariant is not affected.
        
        \item Invariant~\ref{inv:rob:rf}: For any done load $L^*$ for address $a$, assume $S^* = L^*.\FromSt^1$.
        The address computation of $S$ may prevent $L^*$ and $S^*$ from satisfying the invariants here.
        Note that $L^*.\MemAddr^0 = a$ and $S^* = L^*.\FromSt^0$.
        We consider each case of this invariant:
        \begin{itemize}
            \item Invariant~\ref{prop:rob:rf:no-kill}:
            We prove by contradiction, i.e., $S^*$ is killed but $L^*$ is not.
            We have proved that $S^*$ cannot be done, so $S^*$ is not done before $R$ fires.
            Invariant~\ref{prop:rob:rf:not-done} says that $S^* \RobProgOrd^0 L^*$.
            Then $L^*$ is also killed, contradicting with our assumption.
            
            \item Invariant~\ref{prop:rob:rf:addr-data}: This invariant cannot be affected.
            
            \item Invariant~\ref{prop:rob:rf:done-no-st}:
            We need to show that if $S^*$ is done, then it is impossible that $S \RobProgOrd^1 L^*$.
            We prove by contradiction, i.e., assume $S^*.\DoneTS^0 \neq \top$ and $S\RobProgOrd^1 L^*$.
            This implies that $S\RobProgOrd^0 L^*$..
            Invariant~\ref{prop:rob:rf:done-no-st} says that there is no store $S'$ such that $S'.\MemAddr^0 = a$ and $S'\RobProgOrd^0 L^*$.
            Since $L^*$ is not killed in the ROB search of rule $R$, there must be load $L'$ such that $L'.\MemAddr^0 = a$ and $L'.\DoneTS^0 = \top$ and $L'\RobProgOrd^0 L^*$.
            This gives $L' \RobNTPreservePO^0 L^* \Rightarrow L'.\DoneTS^0 \neq \top$, contradicting with previous conclusion.
            Therefore the invariant still holds.
            
            \item Invariant~\ref{prop:rob:rf:done-max}: This invariant is not affected.
            
            \item Invariant~\ref{prop:rob:rf:not-done}: We need to show that if $S^*$ is not done, then it is impossible that $S^* \RobProgOrd^1 S\RobProgOrd^1 L^*$.
            We prove by contradiction, i.e., we assume $S^*.\DoneTS^0\neq \top$ and $S^* \RobProgOrd^1 S\RobProgOrd^1 L^*$.
            This implies $S^* \RobProgOrd^0 S\RobProgOrd^0 L^*$.
            Invariant~\ref{prop:rob:rf:not-done} says that there is no store $S'$ such that $S'.\MemAddr^0 =a$ and $S^*\RobProgOrd^0 S' \RobProgOrd^0 L^*$.
            Since $L^*$ is not killed by the ROB search in rule $R$, there must be load $L'$ such that  $L'.\MemAddr^0 = a$ and $L'.\DoneTS^0 = \top$ and $S\RobProgOrd^0 L'\RobProgOrd^0 L^*$.
            This gives $L' \RobNTPreservePO^0 L^* \Rightarrow L'.\DoneTS^0 \neq \top$, contradicting with previous conclusion.
            Therefore the invariant still holds.
        \end{itemize}
    \end{itemize}
    
    \begin{comment}

        \item 
        If there are not-done loads with computed addresses $a$ between $S$ and $L$ in the ROB, then let $L'$ be the youngest of them in ROB, and the ROB search conducted in $R$ will stop at $L'$.
        This will make $R$ not mark $L$ as done, contradicting with our previous assumption.
        Therefore, any load with computed address $a$ between $S$ and $L$ in the ROB must be done.
        Then the ROB search conducted in $R$ will search through $S$.
        Since the address of $S$ has been computed to be $a$, the data of $S$ must also be computed; otherwise the ROB search will stop at $S$ and will not mark $L$ as done.
        Thus we have $\max(\SeqNumAddr(S), \SeqNumData(S)) < \SeqNum(R)$.
        According to invariant~\ref{inv:rob:data}, since $I_1\RobDataDep S$, we have $\SeqNumDone(I_1) < \max(\SeqNumAddr(S), \SeqNumData(S))$.
        Therefore, $\SeqNumDone(I_1) < \SeqNumDone(L)$, i.e., the invariant holds.
        \item $I_1$ is a load whose address has been computed to be $a$, and there is no store $S$ such that the address of $S$ has been computed to $a$ and $I_1 \RobProgOrd S \RobProgOrd L$:
        Following the same argument as the above case, any load with computed address $a$ between $I_1$ and $L$ in the ROB must be done.
        Therefore, the ROB search conducted in $R$ will search through $I_1$.
        Since the address of $I_1$ has been computed to be $a$, $I_1$ must be one; otherwise the ROB search will stop at $I_1$ and will not mark $L$ as done.
        Thus, $\SeqNumDone(I_1) < \SeqNumDone(L)$, i.e., the invariant holds.
    \end{comment}
\end{enumerate}
\end{proof}


