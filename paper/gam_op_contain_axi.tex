\section{GAM Axiomatic model $\subseteq$ GAM Operational Model}\label{sec:gam_op_contain_axi}

\begin{theorem}
    GAM axiomatic model $\subseteq$ GAM operational model.
\end{theorem}
\begin{proof}
    The goal is that for any legal axiomatic relations $\langle \ProgOrd, \MemOrd, \ReadFrom\rangle$ (which satisfy the GAM axioms), we can run the operational model to give the same program behavior.
    The strategy to run the operational model consists of two major phases.
    In the first phase, we only fire Fetch rules to fetch all instructions into all ROBs according to $\ProgOrd$.
    During the second phase, in each step we fire a rule that either marks an instruction as done or computes the address or data of a memory instruction.
    Which rule to fire in a step depends on the current state of the operational model and $\MemOrd$.
    Here we give the detailed algorithm that determines which rule to fire in each step:
    \begin{enumerate}
        \item If in the operational model there is a not-done reg-to-reg or branch instruction whose source registers are all ready, then we fire an Execute-Reg-to-Reg or Execute-Branch rule to execute that instruction.
        \item If the above case does not apply, and in the operational model there is a memory instruction, whose address is not computed but the source registers for the address computation are all ready, then we fire a Compute-Mem-Addr rule to compute the address of that instruction.
        \item If neither of the above cases applies, and in the operational model there is a store instruction, whose store data is not computed but the source registers for the data computation are all ready, then we fire a Compute-Store-Data rule to compute the store data of that instruction.
        \item If none of the above cases applies, and in the operational model there is a fence instruction and the guard of the Execute-Fence rule for this fence is ready, then we fire the Execute-Fence rule to execute that fence.
        \item \label{sim:mem} If none of the above cases applies, then we find the oldest instruction in $\MemOrd$, which is not-done in the operational model, and we fire an Execute-Load or Execute-Store rule to execute that instruction.
    \end{enumerate}
    Before giving the invariants, we give a definition related  to the ordering of stores for the same address.
    For each address $a$, all stores for $a$ are totally ordered by $\MemOrd$, and we refer to this total order of stores for $a$ as $<_{co}^a$.
    
    Now we show the invariants.
    After each step, we maintain the following invariants:
    \begin{enumerate}
        \item The order of instructions in each ROB in the operational model is the same as the $\ProgOrd$ of that processor in the axiomatic relations.
        \item \label{inv:result} The results of all the instructions that have been marked as done so far in the operational model are the same as those in the axiomatic relations.
        \item All the load/store addresses that have been computed so far in the operational model are the same as those in the axiomatic relations.
        \item All the store data that have been computed so far in the operational model are the same as those in the axiomatic relations.
        \item \label{inv:no-kill} No kill has ever happened in the operational model.
        \item For the rule fired in each step that we have performed so far, the guard of the rule is satisfied the at that step (i.e., the rule can fire).
        \item \label{inv:done} In each step that we have performed so far, if we fire a rule to execute an instruction (especially a load) in that step, the instruction must be marked as done by the rule.
        \item \label{inv:store} For each address $a$, the order of all the store updates on monolithic memory address $a$ that have happened so far in the operational model is a prefix of $<_{co}^a$.
    \end{enumerate}
    We now examine each option that we may choose in each step of phase 2, and verify that all invariants hold.
    \begin{enumerate}
        \item We execute a reg-to-reg or branch instruction: trivial.
        
        
        \item We compute the address of a load or store instruction $I$: we only need to verify invariant~\ref{inv:no-kill}, i.e., this address computation will not kill any done load.
        Assume the address of $I$ is $a$, and $I$ is in processor $i$.   
        We prove by contradiction, i.e., we assume the address computation of $I$ kills a done load $L$ in the ROB of processor $i$.
        We search $\ProgOrd$ of processor $i$ from $L$ towards the oldest instruction (excluding $L$).
        We stop the search when we find a load or store instruction for address $a$ (note that all addresses in $\ProgOrd$ are known).
        We refer to the instruction found as $I_a$.
        Since $I$ has address $a$, either $I=I_a$ or $I \ProgOrd I_a$.
        If $I=I_a$, then $I_a$ is not-done and its address is not computed before the kill.
        In case of $I \ProgOrd I_a$, $I_a$ cannnot be a done store (because the address of $I$ is just computed).
        In this case, $I_a$ must be not-done and its address must not  be computed, otherwise $L$ will not be killed.
        In either case, $I_a$ must be not-done and the address of $I_a$ is not computed before the kill.
        We also have the following observation:
        \begin{itemize}
            \item $L$ can only become done via option~\ref{sim:mem} in a previous step, so for any not-done memory instruction $I'$ in the operational model, we have $L \MemOrd I'$ in the axiomatic relations.
        \end{itemize}
        We consider the following two possibilities:
        \begin{enumerate}
            \item $I_a$ is a load: In this case, the above observation says that $L \MemOrd I_a$.
            However, since there is no other memory instruction for address $a$ between $I_a$ and $L$ in processor $i$, $I_a \SameAddrOrd L \Rightarrow I_a \MemOrd L$.
            Thus this case is impossible.
            
            \item $I_a$ is a store: In this case, we consider which store is read by $L$.
            \begin{enumerate}
                \item $L$ bypasses from a store $S$ in processor $i$.
                $S$ must be older than $I_a$ in ROB (because address of $I_a$ is not computed at the time when $L$ is executed), so $S \ProgOrd I_a \Rightarrow S \MemOrd I_a$.
                This contradicts with the Load-Value axiom.
                
                \item $L$ reads the value of a store $S$ from the monolithic memory.
                Since all the done stores for $a$ form the prefix of $<_{co}^a$ and $I_a$ is not-done, $S <_{co}^a I_a \Rightarrow S\MemOrd I_a$.
                This also contradicts with the Load-Value axiom.
            \end{enumerate}
        \end{enumerate}
        Therefore this address computation cannot cause any kill.
        
        
        \item We compute a store data: trivial.
        
        \item We execute a fence instruction: trivial.
        
        
        \item We execute a memory instruction $I$ from $\MemOrd$: 
        First note that for any memory instruction $I'$ such that $I' \MemOrd I$, $I'$ must be done in the operational model (because of the way we pick $I$).
        We now prove according to the type of $I$.
        \begin{itemize}        
            \item $I$ is a store for address $a$: we first show that all the guards are satisfied:
            \begin{enumerate}
                \item Address and data of $I$ have been computed:
                We prove by contradiction, i.e., the address or data of $I$ has not been computed.
                We backtrack the dependency chain on $I$.
                The only reason for not being able to compute the address or data of $I$ is that an older instruction $I_1$ is not-done, and that $I_1 \DataDep I$.
                $I_1$ can only be a not-done reg-to-reg instruction or a not-done load.
                If $I_1$ is a reg-to-reg instruction, it cannot be computed because of a not-done instruction $I_2 \DataDep I_1$.
                We trace this dependency chain until we encounter a load, i.e., $I_k \DataDep I_{k-1} \DataDep \ldots \DataDep I_1 \DataDep I$, where $I_k$ is a not-done load and $I_1\ldots I_{k-1}$ are all not-done reg-to-reg instructions.
                Now we have $I_k \PreservePO I \Rightarrow I_k \MemOrd I$, contradicting with the way we pick $I$ in option~\ref{sim:mem}.
                
                \item All older memory or fence instructions that are ordered before $I$ by $\OrderedFunc$ are done:
                We prove by contradiction, i.e., assume there is a not-done memory or fence instruction $I_1$ that is older than $I$ in ROB and satisfies $\OrderedFunc(I_1, I)$.
                This implies $I_1 \ProgOrd I \Rightarrow I_1\LSFOrd I$.
                If $I_1$ is a not-done fence, the guard to execute it in the operational model must be false according to our algorithm.
                Therefore, there must be a not-done memory or fence instruction $I_2$ that is older than $I_1$ in ROB and satisfies $\OrderedFunc(I_2, I_1)$.
                This implies $I_2\LSFOrd I$.
                We keep backtracking if $I_2$ is also a not-done fence.
                We stop backtracking until $I_k$ is a not-done memory instruction.
                That is, we have $I_k \LSFOrd I_{k-1} \LSFOrd\cdots\LSFOrd I_1 \LSFOrd I \Rightarrow I_k \MemOrd I$.
                Since $I_k$ is a not-done memory instruction, this contradicts with the way we pick $I$ in option~\ref{sim:mem}.
                Therefore, such $I_1$ does not exist.
                
                \item All older branches are done:
                We prove by contradiction, i.e., an older branch $B$ in the ROB of $I$ is not-done.
                We backtrack the dependency chain on $B$, and get $I_k \DataDep I_{k-1} \DataDep \ldots \DataDep I_1 \DataDep B$, where $I_k$ is a not-done load and $I_1\ldots I_{k-1}$ are all not-done reg-to-reg instructions.
                Since $B \ProgOrd I$, we have $I_k \PreservePO B \DepOrd I \Rightarrow I_k \PreservePO I \Rightarrow I_k \MemOrd I$, contradicting with the way we pick $I$ in option~\ref{sim:mem}.
                
                \item All older loads and stores have computed their addresses:
                We prove by contradiction, i.e., an older load or store $I'$ in the ROB of $I$ has not computed its address.
                We backtrack the dependency chain on the address of $I'$, and get $I_k \DataDep I_{k-1} \DataDep \ldots \DataDep I_1 \AddrDep I'$, where $I_k$ is a not-done load and $I_1\ldots I_{k-1}$ are all not-done reg-to-reg instructions.
                Since $I' \ProgOrd I$, we have $I_k \PreservePO I_1 \DepOrd I \Rightarrow I_k \PreservePO I \Rightarrow I_k \MemOrd I$, contradicting with the way we pick $I$ in option~\ref{sim:mem}.
                
                \item All older loads and stores for address $a$ are done:
                For any store $S$ for address $a$ that is older than $I$ in the ROB of $I$, we have $S \SameAddrOrd I \Rightarrow S \MemOrd I$.
                Therefore, $S$ must be done.
                For any load $L$ for address $a$ that is older than $I$ in the ROB of $i$, we have $L \SameAddrOrd I\Rightarrow L \MemOrd I$.
                Therefore, $L$ must be done.
            \end{enumerate}
            We now only need to verify invariant~\ref{inv:store}.
            This is trivial, because all stores for $a$ that is older than $I$ in $<_{mo}$ are done (i.e., have updated $m[a]$).
            
            \item $I$ is a load for address $a$:
            we first show that all the guards are satisfied:
            \begin{enumerate}
                \item Address of $I$ has been computed: same argument as store case.
                \item All older memory or fence instructions that are ordered before $I$ by $\OrderedFunc$ are done: same argument as store case.
            \end{enumerate}
            We now need to verify invariants~\ref{inv:result} and \ref{inv:done}.
            To do this, we consider the three possible outcomes of the ROB search in the Execute-Load rule that executes $I$:
            \begin{enumerate}
                \item The search finds a not-done load $L$: We prove that this case is impossible (for invariant~\ref{inv:done}) by contradiction.
                If there are intervening stores for $a$ between $L$ and $I$ in the ROB, none of those stores can be done, because the not-done load $L$ will make the guards of Execute-Store rules fail.
                Let $S$ be the youngest store among these stores.
                $S$ must not have computed its address, because otherwise the search will stop at $S$.
                Now we backtrack the dependency chain on the address of $S$, and get $I_k \DataDep I_{k-1} \DataDep \ldots \DataDep I_1 \DataDep S$, where $I_k$ is a not-done load and $I_1\ldots I_{k-1}$ are all not-done reg-to-reg instructions.
                Since there is no store for $a$ between $S$ and $I$, we have $I_k \PreservePO I_1 \DepOrd I\Rightarrow I_k \PreservePO I \Rightarrow I_k \MemOrd I$.
                Since $I_k$ is not done, this contradicts with the way we pick $I$ in option~\ref{sim:mem}.
                Therefore, there is no store for $a$ between $L$ and $I$ in the ROB.
                Then we have $L \SameAddrOrd I \Rightarrow L \MemOrd I$.
                Since $L$ is not done, this contradicts with the way we pick $I$ in option~\ref{sim:mem}.

                \item The search finds a not-done store $S$: 
                Using the same argument as above, there cannot be any store for $a$ between $I$ and $S$ in ROB.
                We now prove that the data of the $S$ must have been computed (for invariant~\ref{inv:done}).
                We prove by contradiction, i.e., we assume the data of $S$ is not yet computed.
                We backtrack the dependency chain on the data of $S$, and get $I_k \DataDep I_{k-1} \DataDep \ldots \DataDep I_1 \DataDep S$, where $I_k$ is a not-done load and $I_1\ldots I_{k-1}$ are all not-done reg-to-reg instructions.
                Since there is no store for $a$ between $S$ and $I$, we have $I_k \PreservePO I_1 \DepOrd I \Rightarrow I_k \MemOrd i$, contradicting with the way we pick $i$ in option~\ref{sim:mem} ($j_n$ is a not-done load).
                
                Since the data of $S$ has been computed, $I$ reads from $S$.
                We now need to verify invariant~\ref{inv:result}.
                Since $S$ is not-done, we have $I \MemOrd S$, i.e., the Load-Value axiom can only select from stores $\ProgOrd I$.
                Since there is no other store for $a$ between $S$ and $I$ in the ROB, the Load-Value axiom also agrees on $S\ReadFrom I$.
                
                \item The search finds nothing:
                In this case, $I$ reads from $m[a]$, and we need to verify invariant~\ref{inv:result}.
                We first show that all stores for $a$ older than $I$ in ROB are done.
                If there are not-done stores for $a$ older than $I$ in the ROB, then let $S$ be the youngest one among them.
                There cannot be any done store for $a$ between $S$ and $I$, because the guard of the Execute-Store rule that marks the store as done cannot be satisfied.
                The address of $S$ cannot be computed (otherwise the search will stop at $S$).
                Now we backtrack the dependency chain on the address of $S$ as we do in the first case, and can show a contradiction. 
                
                Assume $m[a]$ is last written by store $S^*$ before this rule fires.
                Thus, for any done store $S'$ for $a$ when this rule fires, either $S' = S^*$ or $S' \MemOrd S^*$.
                Since loads and stores can only be marked as done via option~\ref{sim:mem} in the operational model and $S^*$ is already done, we have $S^* \MemOrd I$.
                For any store $S_1 <_{mo} I$, $S_1$ must be done, so either $S_1 = S^*$ or $S_1 \MemOrd S^*$.
                For any store $S_2 <_{po} I$, $S_2$ is also done, so either $S_2 = S^*$ or $S_2 \MemOrd S^*$.
                Therefore, the Load-Value axiom also agrees on $S^*\ReadFrom I$.
            \end{enumerate}
        \end{itemize}
    \end{enumerate}
\end{proof}
